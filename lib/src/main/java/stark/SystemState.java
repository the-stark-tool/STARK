/*
 * STARK: Software Tool for the Analysis of Robustness in the unKnown environment
 *
 *                Copyright (C) 2023.
 *
 * See the NOTICE file distributed with this work for additional information
 * regarding copyright ownership.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *             http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package stark;

import stark.ds.DataState;
import stark.ds.DataStateExpression;
import stark.ds.DataStateFunction;
import stark.ds.DataStateBooleanExpression;
import stark.perturbation.NonePerturbation;
import stark.perturbation.Perturbation;
import org.apache.commons.math3.random.RandomGenerator;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Optional;
import java.util.function.Function;

/**
 * This interface is implemented to define different models.
 */
public interface SystemState {

    /**
     * Returns the data state associated with this state.
     *
     * @return the data state associated with this state.
     */
    DataState getDataState();

    /**
     * Returns one state sampled among the ones reachable from this state in one step.
     *
     * @param rg random generator used sample random expression.
     * @return one state sampled among the one reachable from this state in one step.
     */
    SystemState sampleNext(RandomGenerator rg);

    /**
     * Returns one state sampled among the ones reachable from this state that satisfy a set of conditions.
     *
     * @param rg random generator used sample random expression.
     * @param cond conditions
     * @return one state sampled among the one reachable from this state that satisfy a set of conditions.
     */
    SystemState sampleNextCond(RandomGenerator rg, DataStateBooleanExpression cond);

    /**
     * Returns the system state in which the current data state is replaced with the given one.
     *
     * @param dataState new data state.
     * @return the system state in which the current data state is replaced with the given one.
     */
    SystemState setDataState(DataState dataState);


    /**
     * Returns the sampling of the given function applied to this system state.
     *
     * @param rg       random generator used in the sampling
     * @param function random function to sample
     * @return the sampling of the given function applied to this system state.
     */
    default SystemState apply(RandomGenerator rg, DataStateFunction function) {
        return this.setDataState(function.apply(rg, this.getDataState()));
    }

    /**
     * Computes the average value obtained by applying the given function experienced in a computation of a
     * length <code>steps</code> starting from <code>system</code>.
     * At each step, <code>size</code> values are sampled.
     *
     * @param rg     random generator used in the sampling
     * @param f      function to evaluate
     * @param system initial state
     * @param steps  number of steps
     * @param size   number of samplings per step
     * @return the average value obtained by applying the given function experienced in a computation of a
     * length <code>steps</code> starting from <code>system</code>
     */
    static double[] sample(RandomGenerator rg, DataStateExpression f, SystemState system, int steps, int size) {
        return sample(rg, f, rgn -> system, steps, size);
    }

    /**
     * Computes the average value obtained by applying the given function experienced in a computation of a
     * length <code>steps</code> starting from systems generated by <code>generator</code>.
     * At each step, <code>size</code> values are sampled.
     *
     * @param rg        random generator used in the sampling
     * @param f         function to evaluate
     * @param generator initial state generator
     * @param steps     number of steps
     * @param size      number of samplings per step
     * @return the average value obtained by applying the given function experienced in a computation of a
     * length <code>steps</code> starting from <code>system</code>
     */
    static double[] sample(RandomGenerator rg, DataStateExpression f, Function<RandomGenerator, SystemState> generator, int steps, int size) {
        SampleSet<SystemState> current = SampleSet.generate(rg, generator, size);
        double[] result = new double[steps];
        for (int i = 0; i < steps; i++) {
            result[i] = Arrays.stream(current.evalPenaltyFunction(f)).average().orElse(Double.NaN);
            current = current.apply(s -> s.sampleNext(rg));
        }
        return result;
    }

    static double[] sample_max(RandomGenerator rg, DataStateExpression f, Function<RandomGenerator, SystemState> generator, int steps, int size) {
        SampleSet<SystemState> current = SampleSet.generate(rg, generator, size);
        double[] result = new double[steps];
        for (int i = 0; i < steps; i++) {
            result[i] = Arrays.stream(current.evalPenaltyFunction(f)).max().orElse(Double.NaN);
            current = current.apply(s -> s.sampleNext(rg));
        }
        return result;
    }

    /**
     * Computes the average value obtained by applying the given function experienced in a computation of a
     * length <code>steps</code> starting from <code>system</code> under the perturbation <code>p</code>.
     * At each step, <code>size</code> values are sampled.
     *
     * @param rg     random generator used in the sampling
     * @param f      function to evaluate
     * @param p      applied perturbation
     * @param system initial state
     * @param steps  number of steps
     * @param size   number of samplings per step
     * @return the average value obtained by applying the given function experienced in a computation of a
     * length <code>steps</code> starting from <code>system</code> under the perturbation <code>p</code>
     */
    static double[] sample(RandomGenerator rg, DataStateExpression f, Perturbation p, SystemState system, int steps, int size) {
        return sample(rg, f, p, r -> system, steps, size);
    }

    /**
     * Computes the average values obtained by applying all functions in a given list experienced in a computation of a
     * length <code>steps</code> starting from <code>system</code> under the perturbation <code>p</code>.
     * At each step, <code>size</code> values are sampled.
     *
     * @param rg     random generator used in the sampling
     * @param F      list of  functions to evaluate
     * @param p      applied perturbation
     * @param system initial state
     * @param steps  number of steps
     * @param size   number of samplings per step
     * @return the average value obtained by applying the given function experienced in a computation of a
     * length <code>steps</code> starting from <code>system</code> under the perturbation <code>p</code>
     */
    static double[][] sample(RandomGenerator rg, ArrayList<DataStateExpression> F, Perturbation p, SystemState system, int steps, int size) {
        return sample(rg, F, p, r -> system, steps, size);
    }

    /**
     * Computes the minimum values obtained by applying all functions in a given list experienced in a computation of a
     * length <code>steps</code> starting from <code>system</code> under the perturbation <code>p</code>.
     * At each step, <code>size</code> values are sampled.
     *
     * @param rg     random generator used in the sampling
     * @param F      list of  functions to evaluate
     * @param p      applied perturbation
     * @param system initial state
     * @param steps  number of steps
     * @param size   number of samplings per step
     * @return the minimum value obtained by applying the given function experienced in a computation of a
     * length <code>steps</code> starting from <code>system</code> under the perturbation <code>p</code>
     */
    static double[][] sample_min(RandomGenerator rg, ArrayList<DataStateExpression> F, Perturbation p, SystemState system, int steps, int size) {
        return sample_min(rg, F, p, r -> system, steps, size);
    }

    /**
     * Computes the maximum values obtained by applying all functions in a given list experienced in a computation of a
     * length <code>steps</code> starting from <code>system</code> under the perturbation <code>p</code>.
     * At each step, <code>size</code> values are sampled.
     *
     * @param rg     random generator used in the sampling
     * @param F      list of  functions to evaluate
     * @param p      applied perturbation
     * @param system initial state
     * @param steps  number of steps
     * @param size   number of samplings per step
     * @return the maximum value obtained by applying the given function experienced in a computation of a
     * length <code>steps</code> starting from <code>system</code> under the perturbation <code>p</code>
     */
    static double[][] sample_max(RandomGenerator rg, ArrayList<DataStateExpression> F, Perturbation p, SystemState system, int steps, int size) {
        return sample_max(rg, F, p, r -> system, steps, size);
    }

    /**
     * In case the perturbation is not specified,
     * the null perturbation is used.
     */
    static double[][] sample(RandomGenerator rg, ArrayList<DataStateExpression> F, SystemState system, int steps, int size) {
        return sample(rg, F, new NonePerturbation(), r -> system, steps, size);
    }

    static double[][] sample_max(RandomGenerator rg, ArrayList<DataStateExpression> F, SystemState system, int steps, int size) {
        return sample_max(rg, F, new NonePerturbation(), r -> system, steps, size);
    }

    static double[][] sample_min(RandomGenerator rg, ArrayList<DataStateExpression> F, SystemState system, int steps, int size) {
        return sample_min(rg, F, new NonePerturbation(), r -> system, steps, size);
    }

    /**
     * Computes the average value obtained by applying the given function experienced in a computation of a
     * length <code>steps</code> starting from systems generated by <code>generator</code> under the
     * perturbation <code>p</code>.
     * At each step, <code>size</code> values are sampled.
     *
     * @param rg        random generator used in the sampling
     * @param f         function to evaluate
     * @param p         applied perturbation
     * @param generator initial state generator
     * @param steps     number of steps
     * @param size      number of samplings per step
     * @return the average value obtained by applying the given function experienced in a computation of a
     * length <code>steps</code> starting from <code>system</code> under the perturbation <code>p</code>
     */
    static double[] sample(RandomGenerator rg, DataStateExpression f, Perturbation p, Function<RandomGenerator, SystemState> generator, int steps, int size) {
        SampleSet<SystemState> current = SampleSet.generate(rg, generator, size);
        double[] result = new double[steps];
        for (int i = 0; i < steps; i++) {
            Optional<DataStateFunction> perturbationEffects = p.effect();
            if (perturbationEffects.isPresent()) {
                current = current.apply(s -> s.apply(rg, perturbationEffects.get()));
            }
            result[i] = Arrays.stream(current.evalPenaltyFunction(f)).average().orElse(Double.NaN);
            current = current.apply(s -> s.sampleNext(rg));
            p = p.step();
        }
        return result;
    }

    /**
     * Computes the average values obtained by applying all functions in a list experienced in a computation of a
     * length <code>steps</code> starting from systems generated by <code>generator</code> under the
     * perturbation <code>p</code>.
     * At each step, <code>size</code> values are sampled.
     *
     * @param rg        random generator used in the sampling
     * @param F         list of functions to evaluate
     * @param p         applied perturbation
     * @param generator initial state generator
     * @param steps     number of steps
     * @param size      number of samplings per step
     * @return the average value obtained by applying the given function experienced in a computation of a
     * length <code>steps</code> starting from <code>system</code> under the perturbation <code>p</code>
     */
    static double[][] sample(RandomGenerator rg, ArrayList<DataStateExpression> F, Perturbation p, Function<RandomGenerator, SystemState> generator, int steps, int size) {
        SampleSet<SystemState> current = SampleSet.generate(rg, generator, size);

        double[][] result = new double[steps][F.size()];

        for (int i = 0; i < steps; i++) {

            Optional<DataStateFunction> perturbationEffects = p.effect();
            if (perturbationEffects.isPresent()) {
                current = current.apply(s -> s.apply(rg, perturbationEffects.get()));
            }

            for (int j = 0; j < F.size(); j++) {
                result[i][j] = Arrays.stream(current.evalPenaltyFunction(F.get(j))).average().orElse(Double.NaN);
            }
            current = current.apply(s -> s.sampleNext(rg));
            p = p.step();
        }
        return result;
    }

    /**
     * Computes the minimum values obtained by applying all functions in a list experienced in a computation of a
     * length <code>steps</code> starting from systems generated by <code>generator</code> under the
     * perturbation <code>p</code>.
     * At each step, <code>size</code> values are sampled.
     *
     * @param rg        random generator used in the sampling
     * @param F         list of functions to evaluate
     * @param p         applied perturbation
     * @param generator initial state generator
     * @param steps     number of steps
     * @param size      number of samplings per step
     * @return the minimum value obtained by applying the given function experienced in a computation of a
     * length <code>steps</code> starting from <code>system</code> under the perturbation <code>p</code>
     */
    static double[][] sample_min(RandomGenerator rg, ArrayList<DataStateExpression> F, Perturbation p, Function<RandomGenerator, SystemState> generator, int steps, int size) {
        SampleSet<SystemState> current = SampleSet.generate(rg, generator, size);
        double[][] result = new double[steps][F.size()];
        for (int i = 0; i < steps; i++) {
            Optional<DataStateFunction> perturbationEffects = p.effect();
            if (perturbationEffects.isPresent()) {
                current = current.apply(s -> s.apply(rg, perturbationEffects.get()));
            }
            for (int j = 0; j < F.size(); j++) {
                result[i][j] = Arrays.stream(current.evalPenaltyFunction(F.get(j))).min().orElse(Double.NaN);
            }
            current = current.apply(s -> s.sampleNext(rg));
            p = p.step();
        }
        return result;
    }

    /**
     * Computes the maximum values obtained by applying all functions in a list experienced in a computation of a
     * length <code>steps</code> starting from systems generated by <code>generator</code> under the
     * perturbation <code>p</code>.
     * At each step, <code>size</code> values are sampled.
     *
     * @param rg        random generator used in the sampling
     * @param F         list of functions to evaluate
     * @param p         applied perturbation
     * @param generator initial state generator
     * @param steps     number of steps
     * @param size      number of samplings per step
     * @return the maximum value obtained by applying the given function experienced in a computation of a
     * length <code>steps</code> starting from <code>system</code> under the perturbation <code>p</code>
     */
    static double[][] sample_max(RandomGenerator rg, ArrayList<DataStateExpression> F, Perturbation p, Function<RandomGenerator, SystemState> generator, int steps, int size) {
        SampleSet<SystemState> current = SampleSet.generate(rg, generator, size);
        double[][] result = new double[steps][F.size()];
        for (int i = 0; i < steps; i++) {
            Optional<DataStateFunction> perturbationEffects = p.effect();
            if (perturbationEffects.isPresent()) {
                current = current.apply(s -> s.apply(rg, perturbationEffects.get()));
            }
            for (int j = 0; j < F.size(); j++) {
                result[i][j] = Arrays.stream(current.evalPenaltyFunction(F.get(j))).max().orElse(Double.NaN);
            }
            current = current.apply(s -> s.sampleNext(rg));
            p = p.step();
        }
        return result;
    }

}


